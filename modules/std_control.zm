/******************************************************************************\
FILE:           std_control.zm
AUTHOR:         Theo Veenker <theo.veenker@beexy.nl>
ADAPTED BY:     -

DESCRIPTION:

Provides the experiment control page. It contains a canvas area for displaying
a copy of the test window, an information area and a row of buttons.

HISTORY:
2017-01-01 TV   Initial version for Zep 2.0
2018-03-06 TV   Improved database/record/attribute initialization (Zep 2.1)

\******************************************************************************/


import std_display;
import std_defs;
import std_control_colors;
import std_control_fonts;
import std_res_browser;
import std_res_editor;
import std_res_new;
import std_pp_browser;
import std_pp_editor;
import std_pp_new;
import std_exp_editor;
import std_exp_kickoff;
import std_database;
import std_options;
import std_stubs;


// Database folder name. Don't change.
const string    DATABASE_DIR    = "db";


// Error value returned when attempting to check out a locked database record.
const int       RECORD_LOCKED   = -2;


const string    SLEEPING_ICON   = "stimuli/images/sleeping.svg";
const string    AWAKE_ICON      = "stimuli/images/eye_open.png";

// Enumeration of experiment control interface states.
enum ControlState
{
    CONTROL_IDLE,               // idle
    CONTROL_READY,              // interface initialized
    CONTROL_RES_EDIT,           // entering/editing researcher record
    CONTROL_PP_EDIT,            // entering/editing participant record
    CONTROL_EXP_EDIT,           // entering/editing experiment record
    CONTROL_GRP_EDIT,           // entering/editing experiment group record
    CONTROL_SES_EDIT,           // entering/editing experiment session record
    CONTROL_KICKOFF,            // in experiment kick-off dialog
    CONTROL_RUNNING,            // experiment running
    CONTROL_ABORTED,            // experimenter activated quit
    CONTROL_FINISHED            // experiment finished (normally or aborted)
}


// Record for mapping key/button values to integer codes.
record KeyCodeMapping
{
    int         key;            // key/button value
    int         code;           // code to be produced for key/button
}


// Record type used in attribute definition creation methods.
record FieldDefInit
{
    string id;                  // Attribute id.
    FieldType type;             // Attribute type.
    string description;         // Attribute description.
    bool is_identifying_info;   // Set if attribute may identify a person.
    bool is_sensitive_info;     // Set if attribute may contain sensitive info.
    bool is_exclude_export;     // Set to exclude attribute from export.
    bool is_show_in_list;       // Set to show attribute in zepman record list.
    bool is_required;           // Set if attribute is required for experiment.
    string enumerator_list;     // Enumerator list (iff type FIELD_TYPE_ENUM).
}


Page control
{
    ControlState state;         // experiment control state (see above)
    string      ppid;           // participant id
    string      resid;          // researcher id

    bool        showthumb;      // if set, show test window thumbnail(s)
    bool        showgaze;       // if set, enable showing gaze symbol
    bool        showfixation;   // if set, enable showing fixation symbol
    bool        warnthumb;      // if set, warn about showing thumbnails

    KeyCodeMapping[] keymap = {}; // key to code mappings
    KeyCodeMapping[] btnmap = {}; // button to code mappings


    post_init()
    {
        if (begin() != OK)
        {
            expdb.close();
            terminate;
        }

//        warnthumb = true;
        layout.canvas.warning.set("<b><i>Welcome</i></b>", true, 1s);
    }


    on_event:close()
    {
        signal(ctrl_window, SYS_QUIT);
    }


    on_event:key_press()
    {
        handle_key(ctrl_window, input_key, input_modifiers);
    }


    on_event:message()
    {
        if (state == CONTROL_RES_EDIT)
        {
            state = CONTROL_READY;
            if (message_arg == SYS_CONTINUE)
                resid = res_browser.resid;
            show_researcher_info();
        }
        else if (state == CONTROL_PP_EDIT)
        {
            state = CONTROL_READY;
            if (message_arg == SYS_CONTINUE)
                ppid = pp_browser.ppid;
            show_participant_info();
        }
        else if (state == CONTROL_EXP_EDIT)
        {
            state = CONTROL_READY;
            show_experiment_info();
        }
        else if (state == CONTROL_KICKOFF)
        {
            if (message_arg == SYS_CONTINUE)
                really_begin_experiment();
            else if (message_arg == SYS_CANCEL)
                cancel_begin_experiment();
        }
        else if (state >= CONTROL_RUNNING)
        {
            if (message_arg == SYS_FINISH) // Sent on exit by experiment object.
            {
                end_experiment();       // Check-in session if not yet done.
                terminate;
            }
            else if (message_arg == SYS_UPDATE)
            {
                if (message_arg2 == 0)
                    show_state_info();
                else
                    clear_state_info();
            }
        }
    }


    VerticalLayout layout
    {
        LabelGadget[] partnames = {};   // label gadgets for part names
        LabelGadget[] partvalues = {};  // label gadgets for part counters


        init()
        {
            spacing = 0;
            options = LAYOUT_ATTACH_LEFT | LAYOUT_ATTACH_RIGHT;
            fill_pattern_color = CONTROL_COLOR;
            min_width = 700;
            min_height = 350;

            partnames.size = 6;
            partnames[0] = info2.state1lab;
            partnames[1] = info2.state2lab;
            partnames[2] = info2.state3lab;
            partnames[3] = info2.state4lab;
            partnames[4] = info2.state5lab;
            partnames[5] = info2.state6lab;
            partvalues.size = 6;
            partvalues[0] = info2.state1;
            partvalues[1] = info2.state2;
            partvalues[2] = info2.state3;
            partvalues[3] = info2.state4;
            partvalues[4] = info2.state5;
            partvalues[5] = info2.state6;
        }


        CanvasGadget canvas
        {
            init()
            {
//                fill_pattern_color = CONTROL_CANVAS_COLOR;
            }


            on_event:resize()
            {
                int nw = num_test_windows();
                if (nw == 1)
                {
                    int availw = actual_width - 10;
                    int availh = actual_height - 10;

                    real factor = real(test_window_width(0)) /
                        test_window_height(0);
                    int w = availw;
                    int h = availh;
                    if (factor * h > w)
                        h = int(w / factor);
                    else
                        w = int(h * factor);

                    outline1.width = w;
                    outline1.height = h;
                    outline1.x = -w / 2;
                    outline1.y = -h / 2;
                    outline1.offset_x = actual_width / 2;
                    outline1.offset_y = actual_height / 2;

                    w -= 8;
                    h -= 8;
                    thumb1.width = w;
                    thumb1.height = h;
                    thumb1.x = -w / 2;
                    thumb1.y = -h / 2;
                    thumb1.offset_x = actual_width / 2;
                    thumb1.offset_y = actual_height / 2;
                }
                else if (nw == 2)
                {
                    int availw = actual_width / 2 - 10;
                    int availh = actual_height - 10;

                    real factor = real(test_window_width(0)) /
                        test_window_height(0);
                    int w = availw;
                    int h = availh;
                    if (factor * h > w)
                        h = int(w / factor);
                    else
                        w = int(h * factor);

                    outline1.width = w;
                    outline1.height = h;
                    outline1.x = -w / 2;
                    outline1.y = -h / 2;
                    outline1.offset_x = actual_width / 4;
                    outline1.offset_y = actual_height / 2;

                    w -= 8;
                    h -= 8;
                    thumb1.width = w;
                    thumb1.height = h;
                    thumb1.x = -w / 2;
                    thumb1.y = -h / 2;
                    thumb1.offset_x = actual_width / 4;
                    thumb1.offset_y = actual_height / 2;

                    factor = real(test_window_width(1)) /
                        test_window_height(1);
                    w = availw;
                    h = availh;
                    if (factor * h > w)
                        h = int(w / factor);
                    else
                        w = int(h * factor);

                    outline2.width = w;
                    outline2.height = h;
                    outline2.x = -w / 2;
                    outline2.y = -h / 2;
                    outline2.offset_x = actual_width * 3 / 4;
                    outline2.offset_y = actual_height / 2;

                    w -= 8;
                    h -= 8;
                    thumb2.width = w;
                    thumb2.height = h;
                    thumb2.x = -w / 2;
                    thumb2.y = -h / 2;
                    thumb2.offset_x = actual_width * 3 / 4;
                    thumb2.offset_y = actual_height / 2;
                }
                else if (nw >= 3)
                {
                    int availw = actual_width / 3 - 10;
                    int availh = actual_height - 10;

                    real factor = real(test_window_width(0)) /
                        test_window_height(0);
                    int w = availw;
                    int h = availh;
                    if (factor * h > w)
                        h = int(w / factor);
                    else
                        w = int(h * factor);

                    outline1.width = w;
                    outline1.height = h;
                    outline1.x = -w / 2;
                    outline1.y = -h / 2;
                    outline1.offset_x = actual_width / 6;
                    outline1.offset_y = actual_height / 2;

                    w -= 8;
                    h -= 8;
                    thumb1.width = w;
                    thumb1.height = h;
                    thumb1.x = -w / 2;
                    thumb1.y = -h / 2;
                    thumb1.offset_x = actual_width / 6;
                    thumb1.offset_y = actual_height / 2;

                    factor = real(test_window_width(1)) /
                        test_window_height(1);
                    w = availw;
                    h = availh;
                    if (factor * h > w)
                        h = int(w / factor);
                    else
                        w = int(h * factor);

                    outline2.width = w;
                    outline2.height = h;
                    outline2.x = -w / 2;
                    outline2.y = -h / 2;
                    outline2.offset_x = actual_width / 2;
                    outline2.offset_y = actual_height / 2;

                    w -= 8;
                    h -= 8;
                    thumb2.width = w;
                    thumb2.height = h;
                    thumb2.x = -w / 2;
                    thumb2.y = -h / 2;
                    thumb2.offset_x = actual_width / 2;
                    thumb2.offset_y = actual_height / 2;

                    factor = real(test_window_width(2)) /
                        test_window_height(2);
                    w = availw;
                    h = availh;
                    if (factor * h > w)
                        h = int(w / factor);
                    else
                        w = int(h * factor);

                    outline3.width = w;
                    outline3.height = h;
                    outline3.x = -w / 2;
                    outline3.y = -h / 2;
                    outline3.offset_x = actual_width * 5 / 6;
                    outline3.offset_y = actual_height / 2;

                    w -= 8;
                    h -= 8;
                    thumb3.width = w;
                    thumb3.height = h;
                    thumb3.x = -w / 2;
                    thumb3.y = -h / 2;
                    thumb3.offset_x = actual_width * 5 / 6;
                    thumb3.offset_y = actual_height / 2;
                }

                warning.x = actual_width / 2;
                warning.y = actual_height / 2;
            }


            RectangleShape outline1
            {
                init()
                {
                    line_width = 1;
                    line_pattern_color = color:black;
                    is_visible = true;
                }
            }


            RectangleShape outline2
            {
                init()
                {
                    line_width = 1;
                    line_pattern_color = color:black;
                    is_visible = true;
                }
            }


            RectangleShape outline3
            {
                init()
                {
                    line_width = 1;
                    line_pattern_color = color:black;
                    is_visible = true;
                }
            }


            ImageShape thumb1
            {
                init()
                {
                    filter = PATTERN_FILTER_FAST;
                }
            }


            ImageShape thumb2
            {
                init()
                {
                    filter = PATTERN_FILTER_FAST;
                }
            }


            ImageShape thumb3
            {
                init()
                {
                    filter = PATTERN_FILTER_FAST;
                }
            }


            RectangleShape gaze
            {
                init()
                {
                    width = 5;
                    height = 5;
                    x = -2.5;
                    y = -2.5;
                    fill_pattern_color = rgb:FF408000;
                }
            }


            CrossShape fixation
            {
                init()
                {
                    radius = 4;
                    line_pattern_color = rgb:FFFF4000;
                }
            }

            ImageShape sleep_state
            {
                init()
                {
                    is_visible = true;
                    width = 100;
                    height= 100;
                    image = AWAKE_ICON;
                }

                void set_sleeping(bool sleeping)
                {
                    if (sleeping)
                        image = SLEEPING_ICON;
                    else
                        image = AWAKE_ICON;
                }

            }


            TextShape warning
            {
                init()
                {
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    line_pattern_color = color:black;
                    hor_alignment = ALIGN_CENTER;
                    ver_alignment = ALIGN_CENTER;
                    text_alignment = ALIGN_CENTER;
                }


                Timer timer
                {
                    on_event:expire()
                    {
                        warning.is_visible = false;
                    }
                }


                void set(string s, bool fancy=false, dur timeout=5s)
                {
                    if (fancy)
                        fancy_text = s;
                    else
                        text = s;
                    is_visible = true;
                    timer.start(now() + timeout);
                }


                void clear()
                {
                    timer.abort();
                    is_visible = false;
                    text = "";
                }
            }
        }


        HorGridLayout info1
        {
            init()
            {
                left_margin = 4;
                top_margin = 4;
                wrap_count = 4;
                options = LAYOUT_EQUAL_WIDTH | LAYOUT_STRETCH_ITEMS_HOR;
                height = -1;
                fill_pattern_color = CONTROL_INFO_COLOR;
            }


            LabelGadget
            {
                init()
                {
                    text = "experiment:";
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_INFO_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget experiment
            {
                init()
                {
                    text = script_name();
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_INFO_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget
            {
                init()
                {
                    text = "status:";
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_INFO_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget expstatus
            {
                init()
                {
                    text = "-";
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_INFO_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget
            {
                init()
                {
                    text = "researcher:";
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_INFO_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget researcher
            {
                init()
                {
                    text = "-";
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_INFO_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget
            {
                init()
                {
                    text = "participant:";
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_INFO_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget participant
            {
                init()
                {
                    text = "-";
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_INFO_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget
            {
                init()
                {
                    text = "group:";
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_INFO_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget group
            {
                init()
                {
                    text = "-";
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_INFO_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget
            {
                init()
                {
                    text = "session:";
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_INFO_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget session
            {
                init()
                {
                    text = "-";
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_INFO_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }
        }


        HorGridLayout info2
        {
            init()
            {
                left_margin = 4;
                top_margin = 4;
                wrap_count = 4;
                options = LAYOUT_EQUAL_WIDTH | LAYOUT_STRETCH_ITEMS_HOR;
                height = -1;
                fill_pattern_color = CONTROL_INFO_COLOR;
            }


            LabelGadget state1lab
            {
                init()
                {
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_STATE_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget state1
            {
                init()
                {
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_INFO_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget state2lab
            {
                init()
                {
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_STATE_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget state2
            {
                init()
                {
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_INFO_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget state3lab
            {
                init()
                {
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_STATE_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget state3
            {
                init()
                {
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_INFO_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget state4lab
            {
                init()
                {
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_STATE_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget state4
            {
                init()
                {
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_INFO_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget state5lab
            {
                init()
                {
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_STATE_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget state5
            {
                init()
                {
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_INFO_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget state6lab
            {
                init()
                {
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_STATE_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }


            LabelGadget state6
            {
                init()
                {
                    font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                    font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                    text_color = CONTROL_INFO_TEXT_COLOR;
                    is_wrapping = false;
                    hor_alignment = ALIGN_BEGIN;
                    ver_alignment = ALIGN_BEGIN;
                }
            }
        }


        LabelGadget status
        {
            init()
            {
                margin = 4;
                font_family = CONTROL_MAIN_INFO_FONT_FAMILY;
                font_size = CONTROL_MAIN_INFO_FONT_SIZE;
                fill_pattern_color = CONTROL_INFO_COLOR;
                text_color = CONTROL_STATUS_TEXT_COLOR;
                is_wrapping = false;
                hor_alignment = ALIGN_BEGIN;
                ver_alignment = ALIGN_BEGIN;
                height = -1;
            }
        }


        HorizontalLayout buttons
        {
            init()
            {
                left_margin = 4;
                right_margin = 4;
                top_margin = 8;
                bottom_margin = 4;
                spacing = 8;
                height = -1;
            }


            ButtonGadget experiment
            {
                init()
                {
                    text = "Experiment";
                    font_family = CONTROL_BUTTON_FONT_FAMILY;
                    font_size = CONTROL_BUTTON_FONT_SIZE;
                    fill_pattern_color = CONTROL_BUTTON_COLOR;
                    text_color = CONTROL_BUTTON_TEXT_COLOR;
                    margin = 5;
                    border = 4;
//                    is_focusable = true;
                }


                on_event:activate()
                {
                    if (state != CONTROL_READY) return;

                    state = CONTROL_EXP_EDIT;

                    exp_editor.action(control);
                }
            }


            ButtonGadget researcher
            {
                init()
                {
                    text = "Researcher";
                    font_family = CONTROL_BUTTON_FONT_FAMILY;
                    font_size = CONTROL_BUTTON_FONT_SIZE;
                    fill_pattern_color = CONTROL_BUTTON_COLOR;
                    text_color = CONTROL_BUTTON_TEXT_COLOR;
                    margin = 5;
                    border = 4;
//                    is_focusable = true;
                }


                on_event:activate()
                {
                    if (state != CONTROL_READY) return;

                    state = CONTROL_RES_EDIT;

                    res_browser.action(resid, control);
                }
            }


            ButtonGadget participant
            {
                init()
                {
                    text = "Participant";
                    font_family = CONTROL_BUTTON_FONT_FAMILY;
                    font_size = CONTROL_BUTTON_FONT_SIZE;
                    fill_pattern_color = CONTROL_BUTTON_COLOR;
                    text_color = CONTROL_BUTTON_TEXT_COLOR;
                    margin = 5;
                    border = 4;
//                    is_focusable = true;
                }


                on_event:activate()
                {
                    if (state != CONTROL_READY) return;

                    state = CONTROL_PP_EDIT;

                    pp_browser.action(ppid, control);
                }
            }


            Spacer spacer
            {
            }


/*
            CheckButtonGadget warn
            {
                init()
                {
                    text = "Warn";
                    font_family = CONTROL_BUTTON_FONT_FAMILY;
                    font_size = CONTROL_BUTTON_FONT_SIZE;
                    text_color = CONTROL_BUTTON_TEXT_COLOR;
                }


                on_event:change()
                {
                    warnthumb  = is_checked;
                }
            }
*/


            ButtonGadget help
            {
                init()
                {
                    text = "Help";
                    font_family = CONTROL_BUTTON_FONT_FAMILY;
                    font_size = CONTROL_BUTTON_FONT_SIZE;
                    fill_pattern_color = CONTROL_BUTTON_COLOR;
                    text_color = CONTROL_BUTTON_TEXT_COLOR;
                    margin = 5;
                    border = 4;
//                    is_focusable = true;
                }


                on_event:activate()
                {
                    ctrl_window.show_help();
                }
            }


            ButtonGadget startexp
            {
                init()
                {
                    text = "Start";
                    font_family = CONTROL_BUTTON_FONT_FAMILY;
                    font_size = CONTROL_BUTTON_FONT_SIZE;
                    fill_pattern_color = CONTROL_BUTTON_COLOR;
                    text_color = CONTROL_BUTTON_TEXT_COLOR;
                    margin = 5;
                    border = 4;
//                    is_focusable = true;
                }


                on_event:activate()
                {
                    if (state != CONTROL_READY) return;

                    confirm_begin_experiment();
                }
            }


            ButtonGadget quitexp
            {
                init()
                {
                    text = "Quit";
                    font_family = CONTROL_BUTTON_FONT_FAMILY;
                    font_size = CONTROL_BUTTON_FONT_SIZE;
                    fill_pattern_color = CONTROL_BUTTON_COLOR;
                    text_color = CONTROL_BUTTON_TEXT_COLOR;
                    margin = 5;
                    border = 4;
//                    is_focusable = true;
                }


                on_event:activate()
                {
                    signal(ctrl_window, SYS_QUIT);
                }
            }
        }
    }


    void toggle_thumbnail_quality()
    {
        if (layout.canvas.thumb1.filter == PATTERN_FILTER_FAST)
        {
            if (warnthumb)
            {
                layout.canvas.warning.set("<b>Selected HQ Thumbnails</b>\n\n"
                    "HQ thumbnails are time-wise more expensive\n"
                    "than low quality thumbnails\n\n"
                    "Only enable thumbnails for demonstration purposes\n"
                    "or if experiment isn't visually time-critical",
                    true, 10s);
            }
            layout.canvas.thumb1.filter = PATTERN_FILTER_GOOD;
            layout.canvas.thumb2.filter = PATTERN_FILTER_GOOD;
            layout.canvas.thumb3.filter = PATTERN_FILTER_GOOD;
        }
        else
        {
            if (warnthumb) layout.canvas.warning.clear();
            layout.canvas.thumb1.filter = PATTERN_FILTER_FAST;
            layout.canvas.thumb2.filter = PATTERN_FILTER_FAST;
            layout.canvas.thumb3.filter = PATTERN_FILTER_FAST;
        }
    }


    void toggle_thumbnail(Window win1, Window win2=null, Window win3=null)
    {
        if (showthumb)
        {
            showthumb = false;
            if (warnthumb) layout.canvas.warning.clear();
            layout.canvas.thumb1.image = "";
            layout.canvas.thumb2.image = "";
            layout.canvas.thumb3.image = "";
            layout.canvas.thumb1.is_visible = false;
            layout.canvas.thumb2.is_visible = false;
            layout.canvas.thumb3.is_visible = false;
        }
        else
        {
            showthumb = true;
            if (warnthumb)
            {
                layout.canvas.warning.set("<b>Thumbnails Enabled</b>\n\n"
                    "Only enable thumbnails for demonstration purposes\n"
                    "or if experiment isn't visually time-critical",
                    true);
            }
            if (win1 != null)
            {
                layout.canvas.thumb1.follow_window(win1);
                layout.canvas.thumb1.is_visible = true;
            }
            else
            {
                layout.canvas.thumb1.image = "";
                layout.canvas.thumb1.is_visible = false;
            }
            if (win2 != null)
            {
                layout.canvas.thumb2.follow_window(win2);
                layout.canvas.thumb2.is_visible = true;
            }
            else
            {
                layout.canvas.thumb2.image = "";
                layout.canvas.thumb2.is_visible = false;
            }
            if (win3 != null)
            {
                layout.canvas.thumb3.follow_window(win3);
                layout.canvas.thumb3.is_visible = true;
            }
            else
            {
                layout.canvas.thumb3.image = "";
                layout.canvas.thumb3.is_visible = false;
            }
        }
    }


    void show_gaze(real xeye, real yeye)
    {
        if (!showgaze) return;

        // Parameters are assumed to be in range [0..1>.

        xeye *= layout.canvas.outline1.width - 8;
        yeye *= layout.canvas.outline1.height - 8;

        xeye += layout.canvas.outline1.x + layout.canvas.outline1.offset_x + 4;
        yeye += layout.canvas.outline1.y + layout.canvas.outline1.offset_y + 4;

        layout.canvas.gaze.offset_x = xeye;
        layout.canvas.gaze.offset_y = yeye;
        layout.canvas.gaze.is_visible = true;
    }


    void hide_gaze()
    {
        layout.canvas.gaze.is_visible = false;
    }


    void toggle_show_gaze()
    {
        showgaze = !showgaze;

        if (!showgaze) hide_gaze();
    }


    void show_fixation(real xeye, real yeye)
    {
        if (!showfixation) return;

        // Parameters are assumed to be in range [0..1>.

        xeye *= layout.canvas.outline1.width - 8;
        yeye *= layout.canvas.outline1.height - 8;

        xeye += layout.canvas.outline1.x + layout.canvas.outline1.offset_x + 4;
        yeye += layout.canvas.outline1.y + layout.canvas.outline1.offset_y + 4;

        layout.canvas.fixation.offset_x = xeye;
        layout.canvas.fixation.offset_y = yeye;
        layout.canvas.fixation.is_visible = true;
    }


    void hide_fixation()
    {
        layout.canvas.fixation.is_visible = false;
    }


    void toggle_show_fixations()
    {
        showfixation = !showfixation;

        if (!showfixation) hide_fixation();
    }


    void show_state_info()
    {
        // Show where we are in main "experiment" object.
        int nlabels = layout.partnames.size;
        int nlevels = experiment.num_levels;
        int n;
        int m = 1;
        while (n < nlabels)
        {
            if (m >= nlevels) break;
            int ncycles = experiment.level_num_cycles(m-1);
            int cycle = experiment.level_cycle(m-1);
            if (ncycles > 1)
            {
                layout.partnames[n].text = experiment.level_part_name(m) + ":";
                layout.partvalues[n].text =
                    string(cycle+1) + "/" + string(ncycles);
            }
            else if (ncycles < 0)
            {
                layout.partnames[n].text = experiment.level_part_name(m) + ":";
                layout.partvalues[n].text = string(cycle+1);
            }
            else
            {
                layout.partnames[n].text = experiment.level_part_name(m);
                layout.partvalues[n].text = "";
            }
            n++;
            m++;
        }

        // Also show where we are in the current sub-experiment if defined.
        PartList subexp = experiment.connected;
        if (subexp != null)
        {
            nlevels = subexp.num_levels;
            m = 1;
            while (n < nlabels)
            {
                if (m >= nlevels) break;
                int ncycles = subexp.level_num_cycles(m-1);
                int cycle = subexp.level_cycle(m-1);
                if (ncycles > 1)
                {
                    layout.partnames[n].text = subexp.level_part_name(m) + ":";
                    layout.partvalues[n].text =
                        string(cycle+1) + "/" + string(ncycles);
                }
                else if (ncycles < 0)
                {
                    layout.partnames[n].text = subexp.level_part_name(m) + ":";
                    layout.partvalues[n].text = string(cycle+1);
                }
                else
                {
                    layout.partnames[n].text = subexp.level_part_name(m);
                    layout.partvalues[n].text = "";
                }
                n++;
                m++;
            }
        }

        // Clear remaining labels.
        while (n < nlabels)
        {
            layout.partnames[n].text = "";
            layout.partvalues[n].text = "";
            n++;
        }
    }


    void clear_state_info()
    {
        int nlabels = layout.partnames.size;
        int n;
        while (n < nlabels)
        {
            layout.partnames[n].text = "";
            layout.partvalues[n].text = "";
            n++;
        }
    }


    //--------------------------------------------------------------------------


    bool researcher_exists(string id)
    {
        // Check if researcher record exists.
        return expdb.researcher_exists(id);
    }


    int create_researcher(string id, bool failifexists)
    {
        // Add researcher record if not yet done.
        int err = OK;
        if (!expdb.researcher_exists(id))
        {
            expdb.add_researcher(id);
            if (error()) err = ERROR;
        }
        else if (failifexists)
            err = ERROR;

        return err;
    }


    int check_out_researcher(string id, bool readonly, bool verbose=false)
    {
        if (!is_valid_alphanum(id)) return ERROR;

        // Check out researcher record for desired mode.
        int err = OK;
        if (!expdb.researcher_exists(id))
        {
            err = ERROR;
            if (verbose)
            {
                ctrl_window.show_error("Researcher record \"" + id +
                    "\" doesn't exist.");
            }
        }
        if (!err && !expdb.researcher_accessible(id, readonly))
        {
            err = RECORD_LOCKED;
            if (verbose)
            {
                ctrl_window.show_error("Selected researcher record is locked.");
            }
        }
        if (!err)
        {
            expdb.check_out_researcher(id, readonly);
            if (error()) err = ERROR;
        }

        return err;
    }


    int check_in_researcher()
    {
        // Check in researcher record.
        expdb.check_in_researcher();
        int err = error() ? ERROR : OK;

        return err;
    }


    void show_researcher_info()
    {
        int i = expdb.find_researcher(resid);
        if (i >= 0)
            layout.info1.researcher.text = resid;
        else
            layout.info1.researcher.text = "-";
    }


    //--------------------------------------------------------------------------


    bool participant_exists(string id)
    {
        // Check if participant record exists.
        return expdb.participant_exists(id);
    }


    int create_participant(string id, bool failifexists)
    {
        // Add participant record if not yet done.
        int err = OK;
        if (!expdb.participant_exists(id))
        {
            expdb.add_participant(id);
            if (error()) err = ERROR;
        }
        else if (failifexists)
            err = ERROR;

        return err;
    }


    int check_out_participant(string id, bool readonly, bool verbose=false)
    {
        if (!is_valid_alphanum(id)) return ERROR;

        // Check out participant record for desired mode.
        int err = OK;
        if (!expdb.participant_exists(id))
        {
            err = ERROR;
            if (verbose)
            {
                ctrl_window.show_error("Participant record \"" + id +
                    "\" doesn't exist.");
            }
        }
        if (!err && !expdb.participant_accessible(id, readonly))
        {
            err = RECORD_LOCKED;
            if (verbose)
            {
                ctrl_window.show_error("Selected participant record is locked.");
            }
        }
        if (!err)
        {
            expdb.check_out_participant(id, readonly);
            if (error()) err = ERROR;
        }

        return err;
    }


    int check_in_participant()
    {
        // Check in participant record.
        expdb.check_in_participant();
        int err = error() ? ERROR : OK;

        return err;
    }


    void show_participant_info()
    {
        int i = expdb.find_participant(ppid);
        if (i >= 0)
            layout.info1.participant.text = ppid;
        else
            layout.info1.participant.text = "-";
    }


    //--------------------------------------------------------------------------


    int check_out_experiment(bool readonly)
    {
        // Check out experiment record for desired mode. If the experiment
        // record happens to be in preparing mode the record will be checked
        // out for updating regardless of the value of the readonly flag
        // specified.
        expdb.check_out_experiment(script_name(), readonly);
        int err = error() ? ERROR : OK;

        return err;
    }


    int check_in_experiment()
    {
        // Check in experiment record.
        expdb.check_in_experiment();
        int err = error() ? ERROR : OK;

        return err;
    }


    void show_experiment_info()
    {
        int i = expdb.find_experiment(script_name());
        if (i < 0)
        {
            layout.info1.expstatus.text = "-";
            return;
        }

        ExperimentRecord exp = expdb.experiments[i];
        if (exp.status == EXP_STATUS_PREPARING)
            layout.info1.expstatus.text = "PREPARING";
        else if (exp.status == EXP_STATUS_PILOTING)
            layout.info1.expstatus.text = "PILOTING";
        else if (exp.status == EXP_STATUS_TESTING)
            layout.info1.expstatus.text = "TESTING";
        else if (exp.status == EXP_STATUS_CLOSED)
            layout.info1.expstatus.text = "CLOSED";
    }


    void show_group_info()
    {
        if (num_participant_groups() > 0)
        {
            if (SHOW_ASSIGNED_GROUP)
                layout.info1.group.text = string(selected_group);
            else
                layout.info1.group.fancy_text = "<i>(hidden)</i>";
        }
        else
        {
            layout.info1.group.text = "-";
        }
    }


    void show_session_info()
    {
        layout.info1.session.text = string(expdb.session.id);
    }


    //--------------------------------------------------------------------------


    // Checks to see if field definitions named in check exist in defs.
    bool field_defs_exist(FieldDefinitionArray defs, FieldDefInit[] check)
    {
        int n;
        while (n < check.size)
        {
//            int i = defs.find_field_def(check[n].id);
            int i = defs.find_field_def(check[n].id, check[n].type);
            if (i < 0) return false;
            n++;
        }

        return true;
    }


    // Initializes specified field definition array.
    int init_field_defs(FieldDefinitionArray defs, FieldDefInit[] initdata,
        bool addifnotexists)
    {
        int err = OK;
        int n;
        while (n < initdata.size)
        {
            int i = -1;
            if (addifnotexists)
            {
                i = defs.find_field_def(initdata[n].id, initdata[n].type);
                if (i < 0)
                {
                    i = defs.add_field_def(initdata[n].id, initdata[n].type,
                        false);
                    if (i < 0) err = ERROR;
                }
                else
                    i = -1;     // Definition already exists, don't update it.
            }
            else
            {
                i = defs.add_field_def(initdata[n].id, initdata[n].type, false);
                if (i < 0) err = ERROR;
            }
            if (i >= 0)
            {
                defs.field_defs[i].description =
                    initdata[n].description;
                defs.field_defs[i].is_identifying_info =
                    initdata[n].is_identifying_info;
                defs.field_defs[i].is_sensitive_info =
                    initdata[n].is_sensitive_info;
                defs.field_defs[i].is_exclude_export =
                    initdata[n].is_exclude_export;
                defs.field_defs[i].is_show_in_list =
                    initdata[n].is_show_in_list;
                defs.field_defs[i].is_required =
                    initdata[n].is_required;
                if (initdata[n].type == FIELD_TYPE_ENUM)
                    defs.field_defs[i].enumerator_list =
                        initdata[n].enumerator_list;
            }
            n++;
        }

        return err;
    }


    // Defines which attributes researcher records may have.
    int define_researcher_fields(bool addifnotexists)
    {
        if (field_defs_exist(expdb.researcher_defs, researcher_attribute_defs))
            return OK;

        FieldDefinitionArray defs = expdb.check_out_researcher_defs();
        if (error()) return ERROR;
        int err = init_field_defs(defs, researcher_attribute_defs,
            addifnotexists);
        expdb.check_in_researcher_defs();

        return err;
    }


    // Defines which attributes participant records may have.
    int define_participant_fields(bool addifnotexists)
    {
        if (field_defs_exist(expdb.participant_defs,
                participant_attribute_defs))
            return OK;

        FieldDefinitionArray defs = expdb.check_out_participant_defs();
        if (error()) return ERROR;
        int err = init_field_defs(defs, participant_attribute_defs,
            addifnotexists);
        expdb.check_in_participant_defs();

        return err;
    }


    // Defines which attributes experiment records may have.
    int define_experiment_fields(bool addifnotexists)
    {
        if (field_defs_exist(expdb.experiment_defs, experiment_attribute_defs))
            return OK;

        FieldDefinitionArray defs = expdb.check_out_experiment_defs();
        if (error()) return ERROR;
        int err = init_field_defs(defs, experiment_attribute_defs,
            addifnotexists);
        expdb.check_in_experiment_defs();

        return err;
    }


    // Defines which attributes group records may have.
    int define_group_fields(bool addifnotexists)
    {
        if (field_defs_exist(expdb.group_defs, group_attribute_defs))
            return OK;

        FieldDefinitionArray defs = expdb.check_out_group_defs();
        if (error()) return ERROR;
        int err = init_field_defs(defs, group_attribute_defs, addifnotexists);
        expdb.check_in_group_defs();

        return err;
    }


    // Defines which attributes session records may have.
    int define_session_fields(bool addifnotexists)
    {
        if (field_defs_exist(expdb.session_defs, session_attribute_defs))
            return OK;

        FieldDefinitionArray defs = expdb.check_out_session_defs();
        if (error()) return ERROR;
        int err = init_field_defs(defs, session_attribute_defs, addifnotexists);
        expdb.check_in_session_defs();

        return err;
    }


    // Defines for all types of records the attributes they may have.
    // This requires exclusive access to the database.
    int define_attributes(bool addifnotexists=false)
    {
        // Create record attributes.
        int err = OK;
        if (define_researcher_fields(addifnotexists) != OK) err = ERROR;
        if (define_participant_fields(addifnotexists) != OK) err = ERROR;
        if (define_experiment_fields(addifnotexists) != OK) err = ERROR;
        if (define_group_fields(addifnotexists) != OK) err = ERROR;
        if (define_session_fields(addifnotexists) != OK) err = ERROR;

        return err;
    }


    //--------------------------------------------------------------------------


    // Adds attributes as defined in the database to the researcher record.
    int create_researcher_fields_from_db()
    {
        int err = OK;
        int n;
        while (n < expdb.researcher_defs.num_field_defs)
        {
            FieldDefinition def = expdb.researcher_defs.field_defs[n];
            expdb.researcher.add_field(def.id, false);
            if (error())
            {
                err = ERROR;
                break;
            }
            n++;
        }

        return err;
    }


    // Adds attributes as defined in the database to the participant record.
    int create_participant_fields_from_db()
    {
        int err = OK;
        int n;
        while (n < expdb.participant_defs.num_field_defs)
        {
            FieldDefinition def = expdb.participant_defs.field_defs[n];
            expdb.participant.add_field(def.id, false);
            if (error())
            {
                err = ERROR;
                break;
            }
            n++;
        }

        return err;
    }


    // Adds attributes as defined in the database to the experiment record.
    int create_experiment_fields_from_db()
    {
        int err = OK;
        int n;
        while (n < expdb.experiment_defs.num_field_defs)
        {
            FieldDefinition def = expdb.experiment_defs.field_defs[n];
            expdb.experiment.add_field(def.id, false);
            if (error())
            {
                err = ERROR;
                break;
            }
            n++;
        }

        return err;
    }


    // Adds attributes as defined in the database to the group record.
    int create_group_fields_from_db()
    {
        int err = OK;
        int n;
        while (n < expdb.group_defs.num_field_defs)
        {
            FieldDefinition def = expdb.group_defs.field_defs[n];
            expdb.group.add_field(def.id, false);
            if (error())
            {
                err = ERROR;
                break;
            }
            n++;
        }

        return err;
    }


    // Adds attributes as defined in the database to the session record.
    int create_session_fields_from_db()
    {
        int err = OK;
        int n;
        while (n < expdb.session_defs.num_field_defs)
        {
            FieldDefinition def = expdb.session_defs.field_defs[n];
            expdb.session.add_field(def.id, false);
            if (error())
            {
                err = ERROR;
                break;
            }
            n++;
        }

        return err;
    }


    //--------------------------------------------------------------------------


    // Creates the experiment record, optionally experiment record fields.
    int create_experiment()
    {
        // Add experiment record if not yet done.
        if (!expdb.experiment_exists(script_name()))
        {
            expdb.add_experiment(script_name());
            if (error()) return ERROR;
        }

        return OK;
    }


    // If applicable creates group records and optionally group record fields
    // for each group record.
    int create_groups()
    {
        // Create groups as far as necessary. Note, there can be zero groups.
        int err = OK;
        int ngroups = num_participant_groups();
        if (ngroups > 0)
        {
            TestGroup group;
            while (true)
            {
                string groupname = string(group);
                if (!expdb.group_exists(script_name(), groupname))
                {
                    expdb.add_group(script_name(), groupname);
                    if (error())
                    {
                        err = ERROR;
                        break;
                    }
                }
                if (++group == group.first_enumerator) break;
            }
            if (err) return ERROR;
        }

        return err;
    }


    // Checks if all script defined groups are present in the database for
    // current experiment.
    bool database_has_required_groups()
    {
        int ngroupsexp = num_participant_groups();
        int ngroupsdb = expdb.experiment.num_groups;

        if (ngroupsexp > ngroupsdb) return false;

        bool ok = true;
        if (ngroupsexp > 0)
        {
            TestGroup group;
            while (true)
            {
                if (!expdb.group_exists(script_name(), string(group)))
                {
                    ok = false;
                    break;
                }
                if (++group == group.first_enumerator) break;
            }
        }

        return ok;
    }


    // Checks if groups present in the database for current experiment are
    // also defined by the script.
    bool script_has_required_groups()
    {
        int ngroupsexp = num_participant_groups();
        int ngroupsdb = expdb.experiment.num_groups;

        if (ngroupsexp < ngroupsdb) return false;

        bool ok = true;
        int n;
        while (n < ngroupsdb)
        {
            GroupRecord grp = expdb.experiment.groups[n];
            if (!castable<TestGroup>(grp.id))
            {
                ok = false;
                break;
            }
            n++;
        }

        return ok;
    }


    //--------------------------------------------------------------------------


    int begin_new_session_part1()
    {
        // Check out experiment record. If the experiment record happens to
        // be in preparing mode the record will be checked out for updating
        // regardless of the value of the readonly flag specified. Note, in
        // exclusive access mode we always want to check out for updating.
        int err = check_out_experiment(
            !(EXPERIMENT_RECORD_UPDATEABLE || expdb.num_users < 0));
        if (err) return ERROR;

        // If experiment status is CLOSED fail.
        if (expdb.experiment.status == EXP_STATUS_CLOSED)
        {
            check_in_experiment();
            ctrl_window.show_error("Experiment is marked <b>closed</b>.\n"
                "No more sessions can be run.", true);
            return ERROR;
        }

        // If applicable initialize fixed experiment record fields.
        if (expdb.experiment.lock_counter < 0)
        {
            err = create_experiment_fields();
            if (err)
            {
                check_in_experiment();
                ctrl_window.show_error("Error initializing experiment record "
                    "attributes.");
                return ERROR;
            }
        }

        // Check experiment record fields.
        if (expdb.experiment.has_missing_fields())
        {
            check_in_experiment();
            ctrl_window.show_error("One or more experiment record attributes "
                "not set.");
            return ERROR;
        }
        err = check_experiment_fields();
        if (err)
        {
            check_in_experiment();
            ctrl_window.show_error("Invalid attribute value(s) in experiment "
                "record. See check_experiment_fields()");
            return ERROR;
        }

        // Check if database and script agree about which participant groups
        // exist.
        if (!database_has_required_groups())
        {
            check_in_experiment();
            ctrl_window.show_error("Group records in database don't match "
                "groups defined in script.");
            return ERROR;
        }
        if (!script_has_required_groups())
        {
            check_in_experiment();
            ctrl_window.show_error("Groups defined in script don't match "
                "group records in database.");
            return ERROR;
        }


        // If no researcher specified then substitute current username.
        if (!is_valid_alphanum(resid))
        {
            resid = user_name();
            err = create_researcher(resid, false);
            if (err)
            {
                check_in_experiment();
                return ERROR;
            }
            show_researcher_info();
        }

        // If still no researcher specified then fail.
        if (!is_valid_alphanum(resid))
        {
            check_in_experiment();
            ctrl_window.show_error("No researcher selected.");
            return ERROR;
        }

        // Check out researcher record. Note, in exclusive access mode we
        // always want to check out for updating.
        err = check_out_researcher(resid,
            !(RESEARCHER_RECORD_UPDATEABLE || expdb.num_users < 0), true);
        if (err)
        {
            check_in_experiment();
            return ERROR;
        }

        // If applicable initialize fixed researcher record fields.
        if (expdb.researcher.lock_counter < 0)
        {
            err = create_researcher_fields();
            if (err)
            {
                check_in_researcher();
                check_in_experiment();
                ctrl_window.show_error("Error initializing researcher record "
                    "attributes.");
                return ERROR;
            }
        }

        // Check researcher record fields.
        if (expdb.researcher.has_missing_fields())
        {
            check_in_researcher();
            check_in_experiment();
            ctrl_window.show_error("One or more researcher record attributes "
                "not set.");
            return ERROR;
        }
        err = check_researcher_fields();
        if (err)
        {
            check_in_researcher();
            check_in_experiment();
            ctrl_window.show_error("Invalid attribute value(s) in researcher "
                "record. See check_researcher_fields()");
            return ERROR;
        }


        // If no participant specified and experiment status is PREPARING
        // then substitute 'dummy'.
        if (!is_valid_alphanum(ppid) &&
                expdb.experiment.status == EXP_STATUS_PREPARING)
        {
            ppid = "dummy";
            err = create_participant(ppid, false);
            if (err)
            {
                check_in_researcher();
                check_in_experiment();
                return ERROR;
            }
            show_participant_info();
        }

        // If still no participant specified then fail.
        if (!is_valid_alphanum(ppid))
        {
            check_in_researcher();
            check_in_experiment();
            ctrl_window.show_error("No participant selected.");
            return ERROR;
        }

        // Check out participant record for updating. This assures that a
        // participant can only take part in one session at a time.
        err = check_out_participant(ppid, false, true);
        if (err)
        {
            check_in_researcher();
            check_in_experiment();
            return ERROR;
        }

        // If applicable initialize fixed participant record fields.
        if (expdb.participant.lock_counter < 0)
        {
            err = create_participant_fields();
            if (err)
            {
                check_in_participant();
                check_in_researcher();
                check_in_experiment();
                ctrl_window.show_error("Error initializing participant record "
                    "attributes.");
                return ERROR;
            }
        }

        // Check participant record fields.
        if (expdb.participant.has_missing_fields())
        {
            check_in_participant();
            check_in_researcher();
            check_in_experiment();
            ctrl_window.show_error("One or more participant record attributes "
                "not set.");
            return ERROR;
        }
        err = check_participant_fields();
        if (err)
        {
            check_in_participant();
            check_in_researcher();
            check_in_experiment();
            ctrl_window.show_error("Invalid attribute value(s) in participant "
                "record. See check_participant_fields()");
            return ERROR;
        }


        // If experiment defines groups then select group for participant.
        if (num_participant_groups() > 0)
        {
            // Determine participant group.
            if (num_participant_groups() == 1)
            {
                select_group_default();
            }
            else
            {
                if (have_option("grp"))
                    err = select_group_specified();
                else
                    err = assign_participant_to_group();
                if (err)
                {
                    check_in_participant();
                    check_in_researcher();
                    check_in_experiment();
                    return ERROR;
                }
            }
        }

        return OK;
    }


    int begin_new_session_part2()
    {
        int err;
        if (num_participant_groups() > 0)
        {
            // Check out group record. Note, in exclusive access mode we
            // always want to check out for updating.
            expdb.check_out_group(script_name(), string(selected_group),
                !(GROUP_RECORD_UPDATEABLE || expdb.num_users < 0));
            if (error())
            {
                check_in_participant();
                check_in_researcher();
                check_in_experiment();
                return ERROR;
            }

            // If applicable initialize fixed group record fields.
            if (expdb.group.lock_counter < 0)
            {
                err = create_group_fields();
                if (err)
                {
                    expdb.check_in_group();
                    check_in_participant();
                    check_in_researcher();
                    check_in_experiment();
                    ctrl_window.show_error("Error initializing group record "
                        "attributes.");
                    return ERROR;
                }
            }

            // Check group record fields.
            if (expdb.group.has_missing_fields())
            {
                expdb.check_in_group();
                check_in_participant();
                check_in_researcher();
                check_in_experiment();
                ctrl_window.show_error("One or more group record attributes "
                    "not set.");
                return ERROR;
            }
            err = check_group_fields();
            if (err)
            {
                expdb.check_in_group();
                check_in_participant();
                check_in_researcher();
                check_in_experiment();
                ctrl_window.show_error("Invalid attribute value(s) in group "
                    "record. See check_group_fields()");
                return ERROR;
            }
        }
        show_group_info();


        // Perform pre-session setup.
        err = setup_pre_session();
        if (err)
        {
            expdb.check_in_group();
            check_in_participant();
            check_in_researcher();
            check_in_experiment();
            return ERROR;
        }

        // Create new experiment session record.
        expdb.begin_new_session(EXPERIMENT_VERSION);
        if (error())
        {
            expdb.check_in_group();
            check_in_participant();
            check_in_researcher();
            check_in_experiment();
            return ERROR;
        }

        // Create session fields and initialize from script arguments.
        // Arguments on the command line have format: --arg-name=value
        // We attempt to save each name/value as a session field.
        int n;
        while (n < num_options())
        {
            string opt = replace(option_name(n), '-', ' ');
            if (substring(opt, 0, 4) == "arg ")
            {
                string name = substring(opt, 4, length(opt)-4);
                string value = unescape_specials(option_value(n));
                if (expdb.session.is_valid_field(name, value))
                {
                    expdb.session.set_field(name, value);
                    if (error()) err = ERROR;
                }
                else
                {
                    ctrl_window.show_error("Invalid session argument: " +
                        name + "=\"" + value + "\".\n");
                    err = ERROR;
                }
            }
            n++;
        }
        if (!err && expdb.session.has_missing_fields())
        {
            ctrl_window.show_error("One or more session record attributes not "
                "set.\n\n"
                "Use <b>zepdb2dump -defs</b> to list the attributes. "
                "Then rerun the script\nspecifying the required session "
                "attribute(s) as script argument(s) like so:\n"
                "    <tt>--arg-<i>name</i>=<i>value</i></tt>\n"
                "where <tt><i>name</i></tt> and <tt><i>value</i></tt> "
                "represent the attribute's name resp. value.", true);
            err = ERROR;
        }
        if (err)
        {
            int sesid = expdb.session.id;
            expdb.end_session(SESSION_STATUS_FAILED);   // Will check-in all.
            expdb.remove_session(script_name(), sesid); // Remove session.
            return ERROR;
        }

        // Load item table(s) from CSV file(s).
        err = load_item_tables();
        if (err)
        {
            int sesid = expdb.session.id;
            expdb.end_session(SESSION_STATUS_FAILED);   // Will check-in all.
            expdb.remove_session(script_name(), sesid); // Remove session.
            return ERROR;
        }

        // Perform session setup.
        err = setup_session();
        if (err)
        {
            int sesid = expdb.session.id;
            expdb.end_session(SESSION_STATUS_FAILED);   // Will check-in all.
            expdb.remove_session(script_name(), sesid); // Remove session.
            return ERROR;
        }
        show_session_info();

        return OK;
    }


    int end_session(SessionStatus status)
    {
        // Check in experiment session, group, participant, researcher and
        // experiment records.
        expdb.end_session(status);  // Will check-in all other records.
        int err = error() ? ERROR : OK;

        return err;
    }


    int confirm_begin_experiment()
    {
        if (state != CONTROL_READY) return ERROR;

        int err = begin_new_session_part1();
        if (err) return ERROR;

        state = CONTROL_KICKOFF;
        exp_kickoff.action(this);

        return OK;
    }


    int cancel_begin_experiment()
    {
        if (state != CONTROL_KICKOFF) return ERROR;

        check_in_participant();
        check_in_researcher();
        check_in_experiment();

        state = CONTROL_READY;

        return OK;
    }


    int really_begin_experiment()
    {
        if (state != CONTROL_KICKOFF) return ERROR;

        int err = begin_new_session_part2();
        if (err)
        {
            state = CONTROL_READY;
            return ERROR;
        }

        state = CONTROL_RUNNING;

        layout.buttons.participant.is_managed = false;
        layout.buttons.researcher.is_managed = false;
        layout.buttons.experiment.is_managed = false;
        layout.buttons.startexp.is_managed = false;

        experiment.reference_time = event_time;
        experiment.enter();

        return OK;
    }


    void end_experiment(bool abort=false)
    {
        if (abort && state == CONTROL_RUNNING)
            state = CONTROL_ABORTED;

        if (state == CONTROL_RUNNING || state == CONTROL_ABORTED)
        {
            int err;
            if (state == CONTROL_RUNNING)
                err = end_session(SESSION_STATUS_FINISHED);
            else
                err = end_session(SESSION_STATUS_ABORTED);
            if (err) return;

            // Close the database.
            expdb.close();

            state = CONTROL_FINISHED;
        }
    }


    int stop_experiment()
    {
        if (state != CONTROL_RUNNING) return ERROR;

        signal(experiment, SYS_STOP);

        return OK;
    }


    int quit_experiment()
    {
        if (state != CONTROL_IDLE &&
            state != CONTROL_READY &&
            state != CONTROL_RUNNING &&
            state != CONTROL_ABORTED &&
            state != CONTROL_FINISHED) return ERROR;

        if (state == CONTROL_RUNNING)
            state = CONTROL_ABORTED;

        if (state >= CONTROL_RUNNING)
            experiment.leave();

        return OK;
    }


    void mark_experiment_aborted()
    {
        if (state == CONTROL_RUNNING)
            state = CONTROL_ABORTED;
    }


    int begin()
    {
        if (state == CONTROL_READY) return OK;
        if (state != CONTROL_IDLE) return ERROR;

        // Open the database. Will stay open until script termination or
        // end_experiment(). If --nestdb flag is specified then assume
        // database is found in <scriptdir>/db/ otherwise assume it is in
        // <expdir>/db/.
        string dbdir = flag_value("nestdb")
            ? script_dir() : experiment_dir();
        dbdir += DATABASE_DIR;
        if (!file_exists(dbdir)) create_dir(dbdir);
        string dbfn = dbdir + "/zep.db";
        expdb.open(dbfn);
        if (error()) return ERROR;

        // If --prepattr flag specified define all record attributes.
        // Note, this requires exclusive access to the database.
        bool quit = false;
        if (flag_value("prepattr"))
        {
            define_attributes(false);
            quit = true;
        }
        // If --prepexp flag specified create experiment record and group
        // records.
        int err;
        if (flag_value("prepexp"))
        {
            err = create_experiment();
            if (!err) create_groups();
            quit = true;
        }
        // Exit if --prepattr and/or --prepexp was given.
        if (quit)
        {
            expdb.close();
            return 1;
        }

        // In exclusive database access mode or if only one user then
        // define missing attributes on-the-fly.
        if (expdb.num_users < 0 || expdb.num_users == 1)
        {
            err = define_attributes(true);  // Only add NEW attribute defs.
            if (err)
            {
                print_error("Defining record attributes failed.\n");
                return ERROR;
            }
        }

        // Create experiment record if it doesn't yet exist. Note, it should
        // normally already exist.
        err = create_experiment();
        if (err)
        {
            print_error("Creation of experiment record failed.\n");
            return ERROR;
        }

        // Create participant groups as far as necessary.
        err = create_groups();
        if (err)
        {
            print_error("Creation of group records failed.\n");
            return ERROR;
        }

        if (have_option("res"))
        {
            string id = parse_option_researcher_id();
            if (id != "")
            {
                err = create_researcher(id, false);
                if (!err) resid = id;
            }
        }

        if (have_option("pp"))
        {
            string id = parse_option_participant_id();
            if (id != "")
            {
                err = create_participant(id, false);
                if (!err) ppid = id;
            }
        }

        state = CONTROL_READY;

        experiment.target = this;

        // Setup control window and test windows.
        setup_windows();

        // Show what we have.
        clear_state_info();
        clear_status();
        show_experiment_info();
        show_researcher_info();
        show_participant_info();

        return OK;
    }


    void end()
    {
        // Check in experiment session if applicable.
        end_experiment();
    }


    //==========================================================================


    void set_status(string txt)
    {
        layout.status.text = txt;
    }


    void clear_status()
    {
        layout.status.text = "";
    }


    //--------------------------------------------------------------------------


    int find_button(int btn)
    {
        if (btn < 0) return -1;

        int nitems = btnmap.size;

        // If "any button is valid" then return index 0.
        if (nitems == 1 && btnmap[0].key < 0) return 0;

        int n;
        while (n < nitems)
        {
            if (btn == btnmap[n].key) return n;
            n++;
        }

        return -1;
    }


    void enable_button(int btn, int code=CONTINUE)
    {
        if (btn < 0) return;

        // Remove the "any button is valid" entry if present.
        if (btnmap.size == 1 && btnmap[0].key < 0) btnmap.size = 0;

        int i = find_button(btn);
        if (i < 0)
        {
            i = btnmap.size;
            btnmap.size = i + 1;
        }
        btnmap[i].key = btn;
        btnmap[i].code = code;
    }


    void enable_all_buttons(int code=CONTINUE)
    {
        // Create a single "any button is valid" entry.
        btnmap.size = 1;
        btnmap[0].key = -1;
        btnmap[0].code = code;
    }


    void disable_buttons()
    {
        btnmap.size = 0;
    }


    void handle_button(int btn)
    {
        if (state >= CONTROL_RUNNING && target != null)
        {
            int i = find_button(btn);
            if (i >= 0)
                signal_target(btnmap[i].code);
        }
    }


    void handle_voicekey(int action)
    {
        if (state >= CONTROL_RUNNING && target != null)
        {
            int i = find_button(action ? VOICEKEY_ON : VOICEKEY_OFF);
            if (i >= 0 && btnmap[i].key >= 0)
                signal_target(btnmap[i].code);
        }
    }


    //--------------------------------------------------------------------------


    int find_key(int key)
    {
        if (key < 0) return -1;

        int nitems = keymap.size;

        // If "any key is valid" then return index 0.
        if (nitems == 1 && keymap[0].key < 0) return 0;

        int n;
        while (n < nitems)
        {
            if (key == keymap[n].key) return n;
            n++;
        }

        return -1;
    }


    void enable_key(char key, int code=CONTINUE)
    {
        if (int(key) < 0) return;

        // Remove the "any key is valid" entry if present.
        if (keymap.size == 1 && keymap[0].key < 0) keymap.size = 0;

        int i = find_key(int(key));
        if (i < 0)
        {
            i = keymap.size;
            keymap.size = i + 1;
        }
        keymap[i].key = int(key);
        keymap[i].code = code;
    }


    void enable_all_keys(int code=CONTINUE)
    {
        // Create a single "any key is valid" entry.
        keymap.size = 1;
        keymap[0].key = -1;
        keymap[0].code = code;
    }


    void disable_keys()
    {
        keymap.size = 0;
    }


    void handle_key(Page page, char key, int modifiers)
    {
        bool handled;
        if (input_modifiers == 0 && state >= CONTROL_RUNNING && target != null)
        {
            int i = find_key(int(key));
            if (i >= 0)
            {
                signal_target(keymap[i].code);
                handled = true;
            }
        }

        if (!handled) handle_special_key(page, key, modifiers);
    }


    void handle_key(Window win, char key, int modifiers)
    {
        bool handled;
        if (input_modifiers == 0 && state >= CONTROL_RUNNING && target != null)
        {
            int i = find_key(int(key));
            if (i >= 0)
            {
                signal_target(keymap[i].code);
                handled = true;
            }
        }

        if (!handled) handle_special_key(win, key, modifiers);
    }

    void set_sleeping(bool sleeping)
    {
        this.layout.canvas.sleep_state.set_sleeping(sleeping);
    }
}


//------------------------------------------------------------------------------


// Weak stub functions. Keep these here. New stub functions should (mostly)
// be added to std_stubs.zm.


// Loads item table(s) from CSV file(s).
weak int load_item_tables()
{
//    if (test::load_item_tables() != OK) return ERROR;

    return OK;
}
